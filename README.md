# **NUS Orbital 2023**

# **Study Stash**

## _Toh Ming Chun, Marques Tye_

### Artemis

## Motivation

Whenever midterm/exam season rolls around, students always scramble to source for past year practice papers, solutions and cheatsheets. Typically, these resources are located across multiple platforms, such as github repositories, google drives or from seniorsâ€™ personal files. More often than not, these papers would also lack proper solutions and explanations.

## Aim

We hope to make the stressful process of preparing for quizzes, midterms and finals easier by offering a centralised platform for students to access and share resources, including past year papers, solutions, cheatsheets and notes. (Cheatsheets, notes and solutions would be generated by the students)

## User stories

1.  As a student who is revising for exams, I want to be able to easily find the resources that I need, especially solutions for difficult questions. It would also be nice if I could be able to identify at a glance the relative difficulty of the papers and validity of the solutions.

2.  As a student revising for exams, I would like to find users studying the same module and work on problems with them, and discuss the optimal solutions.

3.  As a student who has satisfactorily completed the module, I would like to help the coming batches of students by uploading my compiled cheatsheets, notes and proposed solutions.

## Tech Stack

### Frontend

- React
  - React-hot-toast
  - React-select
  - Jotai (State Management Library)
- TailwindCSS (CSS Framework)
- Framer Motion (Animation Library)
- shadcnUI (UI Library Built upon Radix UI)
- Lucide icons & React-icons (Icon Libraries)

### Meta framework

- NextJS

### Database

- Planetscale (Using MySQL)
- Prisma (Object Relational Mapper)
- AWS S3 (PDF storage)

### Tools

- Typescript
- Jest & React Testing Library (Unit Testing)
- Cypress (E2E Testing)
- ESLint (Linting)
- Prettier (Code Formatting)
- Google OAuth and NextAuth (Authentication)
- Vercel (Hosting and Deployment)

## Design philosophy

Our aim was to create a web app that provides an experience similar to a desktop app, instead of a web page. To create that feeling, we set the main page to be non scrollable, and instead have specific scrollable components when needed.

We also wanted to make the app as accessible as possible without logging in, and thus instead of requiring authentication app-wide, we instead opted to have a fine-grained control over the features that require authentication, and the features that do not.

## Features

## For each feature, include description, implementation (how the code works, UML diagrams), challenges faced (e.g. jotai for atomic state management for the rating in bg issue) (e.g. for sort and filter functionalities, we lifted state into the URL for ease of sharing. challenge: preserve state on navigation)

### Authentication

#### Description

As StudyStash is a personalised revision platform, we require user authentication to provide unique experiences for each user.

For authentication, we decided to use Google's OAuth to make it as easy as possible for users to sign up and log in. We also decided to use NextAuth to handle the authentication flow over implementing it ourself, as we highly valued security and wanted an established library to handle it for our app. It also provides a simple API to handle authentication, and also provide JSON Web Tokens (JWTs) for session tokens.

#### Implementation

When a user logs in through Google OAuth, their name, email and picture is retrieved from Google and stored in the SQL database if the user is not already stored. A JWT is also generated and stored in the browser's cookies, and is used to authenticate the user for subsequent requests. The JWT is crytographically encrypted (via JWE)

(insert authentication flow diagram)

#### Challenges

NUS Authentication?

## Overall navigation flow

show diagram of routing

## Timeline and Development Plan

## Wireframe

<img width="825" alt="image" src="https://github.com/mcmc101001/Orbital2023/assets/96778937/9a22da1d-76a1-4b63-9d54-50db0340e3c2">

Sketches were created using Excalidraw.

## SEO and metadata

### Open Graph Protocol

### Twitter Cards

### Sitemap

## React Component tree

As we are using NextJS 13, we are able to utilise React Server Components, which allows us to create components that are rendered on the server, allowing us to fetch data directly from the database instead of having to call an API endpoint to fetch the data form the client. This also allows us to ship less javascript to the client, improving performance.

## Model Entity Relationship Diagram

show database relationships

## Type validation

Typescript was used to provide static typing to reduce bugs, and more importantly to utilise the Typescript Language Server Protocol to provide autocomplete and type checking in the IDE for a better developer experience.

### Prisma

Prisma not only serves as an object relational mapper for us to interact with the database, but also extends the type definitions of the database to the application, allowing us to perform type checking on the database queries.

### Zod

At the API level, we used Zod to validate the request body at runtime to ensure that the data sent by the user is of the correct type, as well as to extend the benefits of Typescript to the API level.

## User experience

### Instant feedback

To provide instant feedback to the user, we designed our app to be as responsive as possible, with loading states and error messages to inform the user of the status of their request.

### Transitions and animations

Page transitions and animations were used to provide a more seamless experience for the user.

## Testing

### Unit Testing

We used Jest and React Testing Library to conduct unit tests. Unit tests were conducted to ensure that individual components of the application were working as intended.

### End to End Testing

We intend to use Cypress to conduct E2E tests.

### User Testing

We intend to engage users to conduct AB testing to evaluate design choices, and conduct usability testing to identify any pain points in the user experience.

## Software Engineering Practices

### Version control

<img width="696" alt="image" src="https://github.com/mcmc101001/Orbital2023/assets/96778937/fb4989fb-406f-4b84-a863-ec499d2fa934">

The remote master branch is a protected branch containing contains the code used in production, and code cannot be pushed into it directly, instead requiring a pull request to be made before merging, as well as approval by the partner as the code reviewer, as well as passing status checks such as GitGuardian (see Security Measures)

For code review, we come together and discuss the changes to ensure everyone is on the same page.

### Github Issues

<img width="935" alt="image" src="https://github.com/mcmc101001/Orbital2023/assets/96778937/747255a6-f795-4518-9056-b76637d2c0e0">

Github Issues was used to keep track of any bugs in the application and features we wanted to implement. Labels were included to more easily identify the type of issues, be it bugs, features or something we would like to revisit.

### Github Projects

<img width="966" alt="image" src="https://github.com/mcmc101001/Orbital2023/assets/96778937/0e28a4e3-56ca-42bb-b332-971fd07b3b53">

We used Github Projects, which was highly integrated with Github Issues to have a spreadsheet like field of all the issues (and features) and their statuses, making it easy to keep track of the progress of the project.

### Two-week Sprints

### Security Measures

#### Updating dependencies

Dependabot was used to automatically create pull requests to update dependencies to the latest version, allowing us to keep our dependencies up to date to use the latest features, and more importantly to keep our app secure and free from security vulnerabiltiies.

#### Concealing secret keys

Secret keys, such as database (SQL and AWS S3) and authentication (NextAuth and Google OAuth) related information was stored in a .env file and excluded from version control using a gitignore file.

#### GitGuardian

GitGuardian was used to scan for any leaked secret keys in the repository, and would automatically create an issue in the repository if any were found.

#### Protect API routes with server side validation and authentication

To protect our API routes, we would also validate the authenticity of the request sent by the user using JSON Web Token authentication.

(Insert list of API endpoints)

### Linting and code formatting

ESLint was used to perform static analysis of the code to identify stylistic errors and potential bugs, while Prettier was used to format the code on save to boost productivity and ensure consistent code formatting. Config files for both were included in the repository to ensure consistency across all contributors.

### CI/CD

<img width="977" alt="image" src="https://github.com/mcmc101001/Orbital2023/assets/96778937/689e6091-9d63-42a0-8f66-e4b124e9b0c1">

Github Actions and Vercel was utilised to perform Continuous Integration and Continuous Deployment. The CI workflow was triggered on every push to the repository, and would run the production build, followed by unit tests and linting. The CD workflow was triggered on every push to the main branch, and would deploy the application to Vercel.

## Limitations

### No API rate limiting

### No rollbacks to database

## Challenges

### Edge cases

1. long names causing layout shifts, solution: overflow
